---
title: "데이터베이스 정규화(Normalization)"
datePublished: Tue Jul 29 2025 08:58:09 GMT+0000 (Coordinated Universal Time)
cuid: cmdob0ygl001a02l7dvkg70np
slug: normalization
tags: databases, normalization, 7kcv6rec7zmu

---

**데이터베이스 정규화(Normalization)은 데이터의 중복을 최소화하고, 이상현상(Anomaly)을 방지하며, 데이터 무결성을 보장하기 위해 테이블 구조를 체계적으로 분해하는 과정입니다.**

## 정규화의 목적

1. **데이터 중복 제거**
    
    * 같은 데이터가 여러 테이블에 중복 저장되는 것을 방지
        
2. **데이터 이상 현상 방지**
    
    * 삽입 이상 : 특정 데이터를 추가할 때 불필요한 다른 정보까지 강제로 넣어야하는 문제
        
    * 갱신 이상 : 데이터를 수정할 때 중복된 곳을 모두 수정해야 하는 문제
        
    * 삭제 이상 : 데이터를 삭제할 때 의도치 않은 다른 정보까지 사라지는 문제
        
3. **데이터 무결성 유지**
    
    * 관계형 DB의 기본 원칙을 따르고 참조 무결성을 보장
        

---

### 정규화 단계 (Normal Forms)

정규화는 보통 **1NF → 2NF → 3NF → BCNF → 고급 정규형** 순으로 적용됩니다.

---

### 0\. 비정규형 (Unnormalized Form)

| 주문ID | 고객이름 | 고객전화 | 상품ID | 상품명 | 수량 |
| --- | --- | --- | --- | --- | --- |
| 1 | 홍길동 | 010-1111 | A01 | 키보드 | 1 |
| 2 | 홍길동 | 010-1111 | A02 | 마우스 | 2 |
| 3 | 김철수 | 010-2222 | A01 | 키보드 | 1 |

* 고객 정보와 상품 정보가 중복 저장되고 있음
    
* 삽입/갱신/삭제 이상(Anomaly) 발생 가능
    

---

### 1\. 1NF (제1 정규화: 컬럼은 원자값)

> 테이블의 컬럼은 더 이상 쪼갤 수 없는 원자값(Atomic Value) 을 가져야 한다.
> 
> 한 칸에 여러 값이 들어가면 안 된다.

| 주문ID | 고객이름 | 고객전화 | 상품ID | 상품명 | 수량 |
| --- | --- | --- | --- | --- | --- |
| 1 | 홍길동 | 010-1111 | A01 | 키보드 | 1 |
| 2 | 홍길동 | 010-1111 | A02 | 마우스 | 2 |
| 3 | 김철수 | 010-2222 | A01 | 키보드 | 1 |

* 현재 테이블은 이미 원자값 형태라 큰 변화는 없음
    
* 이 단계에서 **주문ID + 상품ID**를 복합키로 인식하여 주문상품 관계를 명확히 함
    

---

### 2\. 2NF (제2 정규화: 부분 함수 종속 제거)

> 기본키의 일부 컬럼에만 종속된 속성을 분리해 완전 함수 종속을 만족시킨다.

* `상품명`은 `상품ID`에만 종속 → 별도 상품 테이블로 분리
    

**\[주문 테이블\]**

| 주문ID | 고객이름 | 고객전화 |
| --- | --- | --- |
| 1 | 홍길동 | 010-1111 |
| 2 | 홍길동 | 010-1111 |
| 3 | 김철수 | 010-2222 |

**\[주문상품 테이블\]**

| 주문ID | 상품ID | 수량 |
| --- | --- | --- |
| 1 | A01 | 1 |
| 2 | A02 | 2 |
| 3 | A01 | 1 |

**\[상품 테이블\]**

| 상품ID | 상품명 |
| --- | --- |
| A01 | 키보드 |
| A02 | 마우스 |

---

### 3\. 3NF (제3 정규화: 이행 함수 종속 제거)

> 기본키가 아닌 컬럼이 또 다른 컬럼을 결정하는 이행적 종속을 제거한다.

* `고객이름 → 고객전화` 종속 발생 → 고객 정보를 별도 테이블로 분리
    

**\[고객 테이블\]**

| 고객ID | 고객이름 | 고객전화 |
| --- | --- | --- |
| C01 | 홍길동 | 010-1111 |
| C02 | 김철수 | 010-2222 |

**\[주문 테이블\]**

| 주문ID | 고객ID |
| --- | --- |
| 1 | C01 |
| 2 | C01 |
| 3 | C02 |

**\[주문상품 테이블\]**

| 주문ID | 상품ID | 수량 |
| --- | --- | --- |
| 1 | A01 | 1 |
| 2 | A02 | 2 |
| 3 | A01 | 1 |

**\[상품 테이블\]**

| 상품ID | 상품명 |
| --- | --- |
| A01 | 키보드 |
| A02 | 마우스 |

---

### 4\. BCNF (Boyce–Codd Normal Form)

> 제3 정규형을 만족한 상태에서, 모든 결정자가 후보키가 되도록 테이블을 분리한다.

* **결정자(Determinant):** 컬럼 A의 값이 컬럼 B의 값을 유일하게 결정하면 `A → B` 관계에서 A를 결정자라고 부른다.
    
* **후보키(Candidate Key)** : 테이블의 행을 유일하게 식별할 수 있는 최소 컬럼 집합
    
* **BCNF 조건:** 테이블 안에서 결정자 역할을 하는 모든 컬럼(또는 컬럼 조합)은 반드시 **후보키**여야 한다.
    
* 복잡한 다대다 관계나 복합키에서 특히 자주 나타나는 이상 현상을 더 엄격히 제거하는 단계.
    

---

### 📌 예시

**강의 테이블**

| 강의ID | 교수ID | 강의실 |
| --- | --- | --- |
| L01 | P01 | R101 |
| L02 | P01 | R101 |
| L03 | P02 | R202 |

* 기본키: `(강의ID, 교수ID)`
    
* `교수ID → 강의실` 관계가 존재
    
* 하나의 강의ID가 여러 교수에게 배정될 수 있다는 상황
    
* 문제: `교수ID`는 후보키가 아닌데 (행을 유일하게 식별할 수 없음) 다른 컬럼(강의실)을 결정하고 있음 → **BCNF 위반**
    

---

### BCNF로 분리

\[강의 테이블\]

| 강의ID | 교수ID |
| --- | --- |
| L01 | P01 |
| L02 | P01 |
| L03 | P02 |

\[교수 테이블\]

| 교수ID | 강의실 |
| --- | --- |
| P01 | R101 |
| P02 | R202 |

* `교수ID → 강의실` 관계를 별도 테이블로 분리
    
* 모든 결정자가 후보키인 상태 → **BCNF 만족**
    

---

## 정리

* **1NF:** 컬럼은 원자값만 가져야 함
    
* **2NF:** 복합키 일부에만 종속된 속성 분리 (부분 함수 종속 제거)
    
* **3NF:** 기본키가 아닌 컬럼 간의 종속 제거 (이행 함수 종속 제거)
    
* **BCNF:** 모든 결정자는 후보키가 되도록 강화
    

---

### 역정규화란 ? (Denormalization)

정규화를 통해 분리한 테이블을 다시 합치거나, 의도적으로 중복 데이터를 허용해 조회 성능을 높이는 설계 방식입니다.

* 정규화는 데이터 무결성에는 유리하지만, 테이블 수가 많아져 조인 비용이 증가하고 조회 속도가 느려질 수 있습니다.
    
* 읽기 위주의 시스템에서는 조인을 줄이고 빠른 조회를 위해 역정규화를 적용하기도 합니다.
    

**중요한 점:**

역정규화는 정규화의 반대 개념이 아니라, 성능과 무결성 사이에서 균형을 맞추기 위한 선택입니다.